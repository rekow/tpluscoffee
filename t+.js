// Generated by CoffeeScript 1.4.0

/*

     _      _            __  __
    | |_  _| |_  __ ___ / _|/ _|___ ___
    |  _||_   _|/ _/ _ \  _|  _/ -_) -_)
     \__|  |_|(_)__\___/_| |_| \___\___|

  t+.coffee - extends t.js with compilation, named blocks,
              includes and extends via simple template loading.

  @author  David Rekow <david at davidrekow.com>
  @license MIT
  @version 0.0.3
*/


(function() {
  var t;

  t = this.t;

  this.t = (function(t) {
    var blocks, extend, include, load, macro, macros, parse, parsed, partial, render, string, templates, trim, triml, trimr, _macro, _t;
    _t = t;
    render = t.prototype.render;
    t.noConflict = function() {
      t = _t;
      return _t;
    };
    partial = /\{\{\s*?\&\s*?([^\s]+?)\s*?\}\}/g;
    extend = /^\{\{\s*?\^\s*?([^\s]+?)\s*?\}\}([.\s\S]*)/g;
    _macro = /\{\{\s*?(\+\s*?([^\(]+))\(([^\)]*)\)\s*?\}\}(?:([\s\S.]+)\{\{\s*?\/\s*?(?:\1|\2)\}\})?/g;
    blocks = /\{\{\s*?(#\s*?([\w]+))\s*?\}\}([\s\S.]+)\{\{\s*?\/\s*?(?:\1|\2)\}\}/g;
    string = function(item) {
      return {}.toString.call(item);
    };
    triml = /^\s+/;
    trimr = /\s+$/;
    trim = function(str) {
      var i, s, _i, _len;
      if (str.charAt) {
        str = str.replace(triml, '').replace(trimr, '');
      } else if (str.length) {
        for (i = _i = 0, _len = str.length; _i < _len; i = ++_i) {
          s = str[i];
          str[i] = trim(s);
        }
      }
      return str;
    };
    templates = {};
    load = function(name, tpl) {
      var _name, _tpl;
      if (!name) {
        return templates;
      }
      if (typeof name === 'object') {
        for (_name in name) {
          _tpl = name[_name];
          load(_name, _tpl);
        }
        return true;
      }
      if (tpl && (tpl.t || tpl.charAt)) {
        tpl = tpl.t || new t(tpl);
        tpl.name = name;
        templates[name] = tpl;
      }
      return templates[name];
    };
    macros = {};
    macro = function(name, fn, ctx) {
      var _fn, _name;
      if (!name) {
        return macros;
      }
      ctx = ctx || null;
      if (typeof name === 'object') {
        ctx = fn || ctx;
        for (_name in name) {
          _fn = name[_name];
          macro(_name, _fn, ctx);
        }
        return true;
      }
      if (fn && typeof fn === 'function') {
        macros[name] = function() {
          return fn.apply(ctx, arguments);
        };
      }
      return macros[name];
    };
    include = function(tpl) {
      return tpl.t.replace(partial, function(_, name) {
        return include(tpl.load(name));
      });
    };
    parsed = {};
    parse = function(tpl, vars) {
      var el, html, src;
      src = tpl.t;
      tpl.t = parsed[tpl.name] || src.replace(extend, function(_, name, rest) {
        var parent, _blocks;
        parent = tpl.load(name);
        if (parent) {
          _blocks = {};
          rest.replace(blocks, function(_, __, $name, inner) {
            return (_blocks[$name] = inner, _);
          });
          return parent.t.replace(blocks, function(_, __, $name, _default) {
            var block;
            block = _blocks[$name];
            return block || _default;
          });
        } else {
          return rest.replace(blocks, function(_, __, $name, inner) {
            return inner;
          });
        }
      });
      parsed[tpl.name] = tpl.t = include(tpl);
      html = render.call(tpl, vars).replace(_macro, function(_, __, name, params, content) {
        var args, m, param, _i, _len;
        params = trim(params.split(','));
        content = content || '';
        m = tpl.macro(name);
        if (m) {
          args = [];
          for (_i = 0, _len = params.length; _i < _len; _i++) {
            param = params[_i];
            args.push(vars[param]);
          }
          try {
            return m.apply(null, args);
          } catch (e) {
            console.log('[t+] Macro error:', e);
          }
        } else {
          console.log('[t+] No macro found:', name);
        }
        return content;
      });
      tpl.t = src;
      if (!tpl._element) {
        return html;
      }
      el = tpl._element;
      return tpl.prerender(el, html, function() {
        var env, newEl;
        env = document.createElement('div');
        env.appendChild(el.cloneNode(false));
        env.firstChild.outerHTML = html;
        tpl._element = newEl = env.firstChild;
        tpl._previousElement = el.parentNode.replaceChild(newEl, el);
        return tpl.postrender(el);
      });
    };
    t.load = t.prototype.load = function(name) {
      return load(name);
    };
    t.register = t.prototype.register = function(name, tpl) {
      return load(name, tpl);
    };
    t.macro = t.prototype.macro = function(name, fn) {
      return macro(name, fn);
    };
    t.parsed = function(name) {
      return parsed[name];
    };
    t.prototype.bind = function(el) {
      if (el && el.nodeType) {
        this._element = el;
      }
      this._previousElement = null;
      return this;
    };
    t.prototype.render = function(vars) {
      return parse(this, vars);
    };
    t.prototype.prerender = function(el, html, cb) {
      return cb();
    };
    t.prototype.postrender = function() {};
    t.prototype.setPrerender = function(fn) {
      if (fn && typeof fn === 'function') {
        this.prerender = fn;
      }
      return this;
    };
    t.prototype.setPostrender = function(fn) {
      if (fn && typeof fn === 'function') {
        this.postrender = fn;
      }
      return this;
    };
    return t;
  })(t);

}).call(this);
